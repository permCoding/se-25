# se-25  

## Regular Expressions  

Для чего они нужны?  
Для поиска данных по условию, фильтрации и замены, подгонки форматов.  

**Регулярка** в языке программирования - это строка состоящая из литералов (символов), метасимволов, квантификаторов и модификаторов, которая задаёт шаблон поиска в строках, извлечения и изменения данных по определённым (заранее заданным) правилам.  

Шаблон интерпретируется движком регулярных выражений согласно правилам, основанным на теории конечных автоматов (математическая абстракция с состояниями и правилами перехода).  

Мажно сказать, что для регулярные выражения реализуют **декларативную парадигму программирования**.  

В **языке SQL** мы не описываем как именно искать данные (циклами, ветвлениями), мы указываем какие данные мы хотим получить (это декларации).  

В **логическом языке** программирования мы также не описываем цыклы и ветвления - мы создаём систему фактов и правил вывода (это декларации) - а машина вывода на этих фактах и правилах работает - выполняет наши запросы.  

В **регулярных выражениях** мы тоже не описываем как именно производить поиск (по шагам с циклами и ветвлениями) - мы просто указываем (декларируем) что именно хотим получить.  

Таким образом, SQL, логические языки, Регулярки - это **языки сверхвысокого уровня** (по аналогии с классом языков высокого уровня - C#, JS, Python).  

Если подходить формально, то SQL, regex и логические языки — это предметно-ориентированные языки (DSL) с декларативной парадигмой.  

DSL (Domain-Specific Language) — это язык программирования, созданный специально для решения задач в конкретной предметной области, в отличие от языков общего назначения (GPL — General-Purpose Language).  

**Примеры шаблонов регулярных выражений**:  

```regex
// номер телефона
\+?\d{1,3}[-.\s]?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}

// email
[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

// дата
\d{2}\.\d{2}\.\d{4}|\d{4}-\d{2}-\d{2}

// IP-адрес
((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)
```

В **Node.js** работа с регулярными выражениями осуществляется с помощью методов самого языка JavaScript -  весь функционал регулярок интегрирован в объекты: `RegExp` и `String`.  

---  

### Методы RegExp  

- `.test(str)` - возвращает true, если строка соответствует шаблону, иначе false  
- `.exec(str)` - возвращает массив с первым совпадением и группами (или null)  

---  

### Методы String  

- `.match(regexp)` - возвращает совпадение (не возвращает скобочные группы)  
- `.matchAll()` (с флагом g) - итератор для всех совпадений  
- `.replace(regexp, replacement)` - заменяет совпадения  
- `.search(regexp)` - возвращает индекс первого совпадения (или -1)  
- `.split(regexp)` - разбивает строку по совпадениям  

---  

### Подключение в JS  

```js
const re_1 = /[A-Z]{2,4}/i;  // 1 - через литерал
const re_2 = new RegExp('[A-Z]{2,4}', 'i'); // 2 - через объект
```

- в объекте используется строка  
- её можно динамически настраивать  

## СИНТАКСИС РЕГУЛЯРОК  

Регулярка - осмысленная цепочка литералов и метасимволов.  
Литералы - обычные символы (латиница, кириллица, цифры и другие) в тексте.  
С кириллицей бывают проблемы.  

### Метасимволы (управляющие)  

```txt
.   любой символ
[ ] множество или класс допустимых символов
[0-9] - любая цифра, - минус в классе обозначает диапазон
[A-Za-z] - диапазонов может быть несколько

\ - обратный слеш для экранирования управляющих символов
подстановки:
\d [0-9]
\D [^0-9] - циркумфлекс - это НЕ
\w [A-Za-z0-9_]
\W [^A-Za-z0-9_]
\s пробельный символ
\S НЕ пробельный символ

[abc] набор допустимых символов
[^abc] набор НЕ допустимых символов

^ якорь начала строки
$ якорь конца строки

\b граница слова (латиница)  
\B НЕ граница слова (латиница)  

x|y ИЛИ

( ) - группа символов
+ * ? - квантификаторы
{ } - выбор диапазона длины цепочки символов
```

### Квантификаторы  

```txt
x* x{0,}
x+ x{1,}
x? x{0,1}
*, + - жадные по умолчанию  
x*? отмена жадности (ленивый)
x+? отмена жадности (ленивый)
x{n} повтор n раз
x{n,} n или более раз
x{n,m} от n до m раз
```

### Группировка  

```txt
(x) задаёт группу, в которую должно попасть выражение x, 
    к которой можно обращаться в дальнейшем по индексу — \1 
    (если группа имеет номер 1)  

(?<name>x) задаёт группу с именем name, в которую должно попасть выражение x
    к группе можно обращаться по имени или по индексу (m.groups.name)  

(?:x) задаёт группу, в которую должно попасть выражение x, 
    к которой нельзя будет обратиться в дальнейшем  

(?#...) это комментарий - при разборе выражения будет проигнорирован
```

### Условия  

```txt
=> справа от подстроки x  
x(?=y) 
- нашли xy в исходной строке
- НЕ захватываем y в результат
- курсор поиска остаётся на позиции до скобки (?=y)  
x(?!y) НЕ захватываем y в результат и ПОСЛЕ x НЕ y

=> слева от подстроки x  
(?<=y)x НЕ захватываем y в результат, но yx есть в исходной  
(?<!y)x НЕ захватываем y в результат и ДО x НЕ y  
```

### Флаги (Модификаторы)  

```txt
g - глобально  
i - игнор регистра символа  
m - мультистроки  
s - все точки - dotAll = [.\n\r] - расширяет поведение символа . на символы переноса строки  
```

---  

Дополнительно:  

> [классы в re](https://javascript.info/regexp-unicode)  
> [для тренировки](https://regex101.com/)  
> [тут можно проверить регулярку](https://regexr.com/)  
> [краткое описание синтаксиса - ШПАРГАЛКА](https://devanych.ru/technologies/shpargalka-po-regulyarnym-vyrazheniyam)  
> [Регулярные выражения за 100 секунд (ENG) - youtube](https://www.youtube.com/watch?v=sXQxhojSdZM)  

---  

---  
вариант задачи:  

```txt
в поле ввода задана температура в градусах Цельсия или Фаренгейта  
требуется распарсить данные и сделать перевод в градусы Фаренгейта (или Цельсия)  
- градусы Фаренгейта могут обозначаться буквами F или f  
- градусы Цельсия могут обозначаться буквами C или c  
- градусы могут быть целым или вещественным числом  
```

примеры входа:  

```js
let arr = [
    '+11.8F',
    '+11.8f',
    '10C',
    '10    C',
    ' - 11.8   C '
];
```

формулы перевода:  
`F = С * 9 / 5 + 32`  
`C = (F - 32) * 5 / 9`  

---  
