# se-25  

## Regular Expressions  

Для чего регулярки - для сбора и обработки данных в строках, включая поиск по условию, фильтрацию и замену, подгонку форматов.  

**Регулярка** в языке программирования - это строка состоящая из `литералов` (символов), `метасимволов`, квантификаторов и модификаторов, которая задаёт шаблон поиска в строках, извлечения и изменения данных по определённым (заранее заданным) правилам.  

Шаблон интерпретируется движком регулярных выражений согласно правилам, основанным на теории конечных автоматов (математическая абстракция с состояниями и правилами перехода).  

Мажно сказать, что для регулярные выражения реализуют **декларативную парадигму программирования**.  

В **языке SQL** мы не описываем как именно искать данные (циклами, ветвлениями), мы указываем какие данные мы хотим получить (это декларации).  

В **логическом языке** программирования мы также не описываем цыклы и ветвления - мы создаём систему фактов и правил вывода (это декларации) - а машина вывода на этих фактах и правилах работает - выполняет наши запросы.  

В **регулярных выражениях** мы тоже не описываем как именно производить поиск (по шагам с циклами и ветвлениями) - мы просто указываем (декларируем) что именно хотим получить.  

Таким образом, `SQL`, `логические языки`, `Регулярки` - это **языки сверхвысокого уровня** (по аналогии с классом языков высокого уровня - C#, JS, Python).  

Если подходить формально, то SQL, regex и логические языки — это предметно-ориентированные языки (DSL) с `декларативной парадигмой`.  

DSL (Domain-Specific Language) — это язык программирования, созданный специально для решения задач в конкретной предметной области, в отличие от языков общего назначения (GPL — General-Purpose Language).  

**Примеры шаблонов регулярных выражений**:  

```regex
// номер телефона
\+?\d{1,3}[-.\s]?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}

// email
[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

// дата
\d{2}\.\d{2}\.\d{4}|\d{4}-\d{2}-\d{2}

// IP-адрес
((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)
```

В **Node.js** работа с регулярными выражениями осуществляется с помощью методов самого языка JavaScript -  весь функционал регулярок интегрирован в объекты: `RegExp` и `String`.  

---  

### Методы RegExp  

- `.test(str)` - возвращает true, если строка соответствует шаблону, иначе false  
- `.exec(str)` - возвращает массив с первым совпадением и группами (или null)  

---  

### Методы String  

- `.match(regexp)` - возвращает совпадение (не возвращает скобочные группы)  
- `.matchAll()` (с флагом g) - итератор для всех совпадений  
- `.replace(regexp, replacement)` - заменяет совпадения  
- `.search(regexp)` - возвращает индекс первого совпадения (или -1)  
- `.split(regexp)` - разбивает строку по совпадениям  

---  

### Подключение в JS  

```js
const re_1 = /[A-Z]{2,4}/i;  // 1 - через литерал
const re_2 = new RegExp('[A-Z]{2,4}', 'i'); // 2 - через объект
```

- в объекте используется строка  
- её можно динамически настраивать  

## СИНТАКСИС РЕГУЛЯРОК  

Регулярка - осмысленная цепочка литералов и метасимволов.  
Литералы - обычные символы (латиница, кириллица, цифры и другие) в тексте.  
С кириллицей бывают проблемы.  
Метасимволы - управляют логикой связывания литералов - кто за кем следует, в каком количестве из какого подмножнства символов.  

### Метасимволы  

#### Управляющие  

```txt
.   любой символ

[ ] множество (класс) допустимых символов
[0-9] - любая цифра, - минус в классе обозначает диапазон
[A-Za-z] - диапазонов может быть несколько

\ - обратный слеш для экранирования управляющих символов
подстановки:
\d [0-9]
\D [^0-9] - циркумфлекс - это НЕ
\w [A-Za-z0-9_]
\W [^A-Za-z0-9_]
\s пробельный символ (пробел, табулятор, перенос строки)  
\S НЕ пробельный символ

[abc] набор допустимых символов
[^abc] набор НЕ допустимых символов

^ якорь начала строки
$ якорь конца строки

\b граница слова (латиница)  
\B НЕ граница слова (латиница)  

x|y ИЛИ

( ) - группа символов
+ * ? - квантификаторы
{ } - выбор диапазона длины цепочки символов
```

* `.` - любой символ  
* `a` - символ буквы "a" (тоже и с другими буквами)  
* `\n` - символ переноса строки  
* `\t` - символ табуляции  

* `\d` - все числа, тоже что и [0-9]  
* `\D` - всё КРОМЕ чисел  
* `\s` - все пробельные символы  
* `\S` - всё кроме пробельных символов  
* `\w` - класс символов [A-Za-z0-9_]  
* `\W` - класс символов [^A-Za-z0-9_]  

* `|` - знак логического ИЛИ  
* `^` - символ начала строки  
* `$` - символ конца строки  

**Например:**  

- `(Bob|Alice)` - "Bob" или "Alice"  
- `^a.*c$` - начинается  с символа "а" (`^a`)? заканчвается на символ "с" (`c$`)  

#### Квантификаторы  

```txt
x* x{0,}
x+ x{1,}
x? x{0,1}
*, + - жадные по умолчанию  
x*? отмена жадности (ленивый)
x+? отмена жадности (ленивый)
x{n} повтор n раз
x{n,} n или более раз
x{n,m} от n до m раз
```

* `*` - 0 и более раз  
* `+` - 1 и более раз  
* `?` - 0 или 1 раз (необязательный символ)  

* `{5}` - ровно 5 раз  
* `{1,5}` - от 1 до 5 раз  
* `{1,}` - от 1 раза  
* `{,5}` - до 5 раз  

**Например:**

- `a+` - символ "a" 1 или более раз  
- `.*` - любой символ 0 или более раз  
- `(www)?` - группа символов "www" 0 или 1 раз  
- `аб{3}` - символ "а" 1 раз, после которого следует "б" 3 раза  

#### Группировка  

```txt
(x) задаёт группу, в которую должно попасть выражение x, 
    к которой можно обращаться в дальнейшем по индексу — \1 
    (если группа имеет номер 1)  

(?<name>x) задаёт группу с именем name, в которую должно попасть выражение x
    к группе можно обращаться по имени или по индексу (m.groups.name)  

(?:x) задаёт группу, в которую должно попасть выражение x, 
    к которой нельзя будет обратиться в дальнейшем  

(?#...) это комментарий - при разборе выражения будет проигнорирован
```

`()` - позволяют использовать `группы` элементов или просто объединять несколько символов  

> По умолчанию всё, что находится в круглых скобках попадает в группы  
> (т.е. отображается в результате поиска),  
> чтобы исключить группу из результатов требуется группу сделать не неиндексируемой: `(?:  )`  

**пример**:  

```js
    let str = `
        https://regex101.com/
        https://www.youtube.com
        http://api.github.com/   `;

    let re = /(?:https?):\/{2}(?:www\.)?(.+)(?:\b)/g;
    console.log([...str.matchAll(re)].map(m => m[1])); 
    // [ 'regex101.com', 'youtube.com', 'api.github.com' ]
```

Внутри регулярки можно адресоваться к созданным группам.  
**backreference** - обратная ссылка  

```js
    let str = `2026 666 1606 27072 7654`;
    // нумерация групп слева-направо по открывающим скобкам
    let re = /((\d)(\d)\d\3\2)/g;
    [...str.matchAll(re)].map(m => m[1]) // [ '27072' ]
```

Незахватывающие группы игнорируются в нумерации - (?:...)  

```js
    let str = `2026 666 1606 27072 7654`;
    let re = /(?:\d)((\d)\d\2)(?:\d)/g;
    [...str.matchAll(re)].map(m => m[1]) // [ '707' ]
```

#### Условия  

```txt
=> справа от подстроки x  
x(?=y) 
- нашли xy в исходной строке
- НЕ захватываем y в результат
- курсор поиска остаётся на позиции до скобки (?=y)  
x(?!y) НЕ захватываем y в результат и ПОСЛЕ x НЕ y

=> слева от подстроки x  
(?<=y)x НЕ захватываем y в результат, но yx есть в исходной  
(?<!y)x НЕ захватываем y в результат и ДО x НЕ y  
```

#### Флаги (Модификаторы)  

```txt
g - глобально  
i - игнор регистра символа  
m - мультистроки  
s - все точки - dotAll = [.\n\r] - расширяет поведение символа . на символы переноса строки  
```

---  

Дополнительно:  

> [классы в re](https://javascript.info/regexp-unicode)  
> [для тренировки](https://regex101.com/)  
> [тут можно проверить регулярку](https://regexr.com/)  
> [краткое описание синтаксиса - ШПАРГАЛКА](https://devanych.ru/technologies/shpargalka-po-regulyarnym-vyrazheniyam)  
> [Регулярные выражения за 100 секунд (ENG) - youtube](https://www.youtube.com/watch?v=sXQxhojSdZM)  

---  
