# Теоретические основы регулярок  

## Регулярные языки — самый простой класс в иерархии формальных языков Хомского

**Иерархия Хомского** — это классификация формальных языков по их сложности организации и выразительной мощности, предложенная Ноамом Хомским в 1950-х годах. Она включает 4 уровня (от сложного - тип 0, к простому - тип 3):  

- тип 0: Рекурсивно перечислимые языки  
- тип 1: Контекстно-зависимые языки  
- тип 2: Контекстно-свободные языки  
- тип 3: РЕГУЛЯРНЫЕ ЯЗЫКИ  

## Что такое регулярные языки?

**Регулярные языки** — самый ограниченный класс формальных языков, они могут быть описаны с помощью очень простых правил и распознаются самыми простыми вычислительными моделями.  

### Формальное определение  

Алфавит - множество символов.  
Строка - цепочка символов.  
Регулярный язык — это множество строк над некоторым алфавитом, которое можно получить с помощью:  

1. **Конечного алфавита**  
2. **Трех базовых операций**:  
   - Конкатенация (соединение)  
   - Объединение (выбор ИЛИ | )  
   - Итерация (повторение И * )  

## Три эквивалентных способа описания регулярных языков  

### 1. Регулярные выражения (практический способ)  

Регулярные выражения — это текстовый способ записи регулярных языков.  

**Базовые элементы:**  

- `a` — один символ "a"
- `ε` — пустая строка
- `∅` — пустой язык (нет ни одной строки)

**Операции:**

- **Конкатенация:** `ab` означает "a", затем "b"  
  - Пример: язык `{ab, abc}` можно описать как `abc?`  
  - вопросительный знак - обозначает необязательный элемент  
  
- **Объединение (|):** `a|b` означает "a" ИЛИ "b"  
  - Пример: язык `{cat, dog}` можно описать как `cat|dog`  
  
- **Итерация (*):** `a*` означает ноль или более повторений "a"  
  - Пример: язык `{ε, a, aa, aaa, ...}` можно описать как `a*`  

**Примеры регулярных языков:**  

```regex
[0-9]+        // все целые числа
[a-zA-Z_][a-zA-Z0-9_]*  // идентификаторы в языках программирования
(https?://)?[a-z0-9.-]+\.[a-z]{2,}  // простой URL
```

### 2. Конечные автоматы (наглядный способ - абстрактная модель)  

Регулярные языки — это формальные языки, которые могут быть распознаны **конечными автоматами**.  

#### Детерминированный конечный автомат (ДКА)  

Представьте себе автомат с:  

- Конечным числом состояний (как комнаты)  
- Переходами между состояниями по символам (как двери с метками)  
- Одним начальным состоянием  
- Одним или несколькими конечными состояниями  

**Пример автомата для языка "строки, содержащие 'ab'":**  

```txt
Состояния: S0, S1, S2 (S2 — конечное)
Алфавит: {a, b}

Переходы:
S0 --a--> S1
S0 --b--> S0
S1 --a--> S1
S1 --b--> S2
S2 --a--> S2
S2 --b--> S2

Этот автомат принимает строки: "ab", "aab", "bab", "abab" и т.д.
```

**Как работает конечный автомат:**  

1. Начинаем в начальном состоянии  
2. Читаем строку символ за символом  
3. Каждый символ переводит автомат в новое состояние  
4. Если после прочтения всей строки мы оказались в конечном состоянии — строка "принята" (принадлежит языку)  

Конечное состояние - это когда все символы терминальные.  

### 3. Регулярные грамматики (самый формальный способ)

Регулярные грамматики — это системы правил для порождения строк языка.

**Правила имеют вид:**  

- `A → aB` (нетерминал порождает терминал и нетерминал)  
- `A → a` (нетерминал порождает терминал)  
- `A → ε` (нетерминал порождает пустую строку)  

Где:  

- Заглавные буквы (A, B) — нетерминалы (вспомогательные символы)  
- Строчные буквы (a, b) — терминалы (символы алфавита)  
- ε — пустая строка  

**Пример грамматики для языка {aⁿ | n ≥ 0} (ноль или больше 'a'):**  

```txt
S → aS | ε

Вывод строки "aaa":
S → aS → aaS → aaaS → aaa
```

## Свойства регулярных языков  

### **Замкнутость**  

Регулярные языки замкнуты относительно операций:  

- Объединение (L₁ ∪ L₂)  
- Пересечение (L₁ ∩ L₂)  
- Дополнение (¬L)  
- Конкатенация (L₁·L₂)  
- Итерация (L*)  
- Обращение (reverse)  

### **Ограничения**

Регулярные языки **не могут**:  

- **Считать**: язык aⁿbⁿ (равное количество a и b) — не регулярный  
- **Создавать вложенные структуры**: язык сбалансированных скобок — не регулярный  
- **Запоминать произвольную информацию**: язык палиндромов — не регулярный  

**Пример нерегулярного языка:**  

```txt
L = { aⁿbⁿ | n ≥ 0 } = { ε, ab, aabb, aaabbb, ... }
```

Этот язык требует подсчета — конечный автомат не может запомнить, сколько a он видел.

## Практические примеры регулярных языков

**Что МОЖНО описать регулярными выражениями**:  

```regex
// Номера телефонов
\+?\d{1,3}[-.\s]?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}

// Email-адреса (упрощенно)
[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

// Даты
\d{2}\.\d{2}\.\d{4}|\d{4}-\d{2}-\d{2}

// IP-адреса
((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)
```

**Что НЕЛЬЗЯ описать регулярными выражениями**:  

```python
# HTML/XML (нужна вложенность тегов)
<div><div></div></div>  # требует подсчета глубины

# Арифметические выражения с вложенными скобками
(2 + (3 * (4 - 1)))  # нужен стек

# Языки вида aⁿbⁿcⁿ
aaabbbccc  # требует подсчета трех разных количеств

# Языки с самоповторением (палиндромы)
"racecar"  # требует сравнения начала и конца
```

---  

Итак, у регулярок есть границы применимости.  
Опыт работы с регулярками поможет понять когда лучше использовать традиционный программный код или совмещать код и регулярки.  

---  
