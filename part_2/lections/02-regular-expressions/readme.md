# se-25  

## Regular Expressions  

В Node.js работа с регулярными выражениями осуществляется с помощью методов самого языка JavaScript, а весь функционал регулярок интегрирован в объекты: `RegExp` и `String`.  

---  

### Методы RegExp  

- `.test(str)` - возвращает true, если строка соответствует шаблону, иначе false  
- `.exec(str)` - возвращает массив с первым совпадением и группами (или null)  

---  

### Методы String  

- `.match(regexp)` - возвращает совпадение (не возвращает скобочные группы)  
- `.matchAll()` (с флагом g) - итератор для всех совпадений  
- `.replace(regexp, replacement)` - заменяет совпадения  
- `.search(regexp)` - возвращает индекс первого совпадения (или -1)  
- `.split(regexp)` - разбивает строку по совпадениям  

---  

### Подключение в JS  

```js
const re_1 = /[A-Z]{2,4}/i;  // 1 - через литерал
const re_2 = new RegExp('[A-Z]{2,4}', 'i'); // 2 - через объект
```

- в объекте используется строка  
- её можно динамически настраивать  

## СИНТАКСИС РЕГУЛЯРОК  

### Управляющие символы  

```txt
.   любой символ
[] множество допустимых символов

\ - обратный слеш для экранирования управляющих символов
\d [0-9]
\D [^0-9] - циркумфлекс - это НЕ
\w [A-Za-z0-9_]
\W [^A-Za-z0-9_]
\s пробельный символ
\S НЕ пробельный символ

[abc] набор допустимых символов
[^abc] набор НЕ допустимых символов
^ якорь начала строки
$ якорь конца строки
\b граница слова
\B НЕ граница слова
x|y ИЛИ

\p{} класс символов
\p{P}u \p{Punct}u это все знаки пунктуации (u - Unicode) == [^\w\s]+
\p{Lu} \p{Ll} любой литерал заглавный или маленький
```

### Квантификаторы  

```txt
x* {0,}
x+ {1,}
x? {0,1}
*, + - жадные по умолчанию  
x*? отмена жадности (ленивый)
x+? отмена жадности (ленивый)
x{n} повтор n раз
x{n,} n или более раз
x{n,m} от n до m раз
```

### Условия  

```txt
=> справа от подстроки x  
x(?=y) 
- нашли xy в исходной строке
- НЕ захватываем y в результат
- курсор поиска остаётся на позиции до скобки (?=y)  
x(?!y) НЕ захватываем y в результат и ПОСЛЕ x НЕ y

=> слева от подстроки x  
(?<=y)x НЕ захватываем y в результат, но yx есть в исходной  
(?<!y)x НЕ захватываем y в результат и ДО x НЕ y  
```

### Группировка  

```txt
(x) задаёт группу, в которую должно попасть выражение x, 
    к которой можно обращаться в дальнейшем по индексу — \1 
    (если группа имеет номер 1)  

(?<name>x) задаёт группу с именем name, в которую должно попасть выражение x
    к группе можно обращаться по имени или по индексу (m.groups.name)  

(?:x) задаёт группу, в которую должно попасть выражение x, 
    к которой нельзя будет обратиться в дальнейшем  

(?#...) это комментарий - при разборе выражения будет проигнорирован
```

### Метасимволы  

```txt
^ $ - контроль начала и конца строки
[ ]
( )
\ |
+ * ?
{ }
< >
```

### Флаги  

```txt
g - глобально  
i - игнор регистра символа  
m - мультистроки  
s - все точки - dotAll = [.\n\r] - расширяет поведение символа . на символы переноса строки  

```

---  

Дополнительно:  

> [классы в re](https://javascript.info/regexp-unicode)  
> [для тренировки](https://regex101.com/)  

---  

вариант задачи:  
в поле ввода задана температура  
в градусах Цельсия или Фаренгейта  
требуется распарсить данные  
и сделать перевод  
в градусы Фаренгейта (или Цельсия)  
градусы фаренгейта могут обозначаться буквами F или f  
градусы фаренгейта могут обозначаться буквами C или c  
градусы могут быть целым или вещественным числом  

примеры входа:  

```js
let arr = [
    '+11.8F',
    '+11.8f',
    '10C',
    '10    C',
    ' - 11.8   C '
];
```

```txt
формулы перевода:  
F = С * 9 / 5 + 32  
C = (F - 32) * 5 / 9  
```

---  
