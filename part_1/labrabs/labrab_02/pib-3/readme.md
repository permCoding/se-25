# lab_02

### Основы синтаксиса JS  

**Модули, циклы, ветвления, массивы**  

---  

## task 01  

Написать **функцию** генерации массива случайных целых чисел, отсортированных по возрастанию.  
Аргументы функции:  
- длина массива,  
- диапазон генерации случайного целого числа `(min, max)`.  
Имя функции: `getArrayIncIntegers(len, mn, mx)`.  

> получить массив с возрастающими целыми числами
> get an array with increasing integers

Функцию разместить в отдельном модуле - utils.js и проверить её работу, вызывая из отдельной программы.  
Если параметры функции заданые некорректно (max < min или длина массива меньше, чем диапазон от min до max), то возвращать пустой массив `[ ]`.  
Например, для вызова `getArrayIncIntegers(5, 10, 99)` возможет результат: `[12, 20, 24, 81, 91]`.  

# task 02  

Сгенерировать массив отсортированных по возрастанию целых чисел (диапазон можете подобрать сами под условия задач 02.1 и 02.2).  

> **02.1**  

Написать **функцию** бинарного поиска позиции числа в отсортированном массиве целых чисел. Если число не находится, возвращать -1. Сравнить среднее количество шагов `при линейном` поиске и `при бинарном`.  

> **02.2**  

Написать **функцию** интерполяционного поиска числа в отсортированном массиве. Если число не находится, возвращать -1. Сравнить среднее количество шагов `при интерполяционном` поиске и `при бинарном`.  

При интерполяционном поиске диапазон поиска делят **НЕ** на две равные части (как в бинарном), а на две неравные - нужно вычислить из пропорции:  

- где именно может находиться искомый элемент - ближе к началу, к середине, к концу оставшейся части диапазона поиска.  

Например, пусть оставшаяся часть - от arr[0]=100 до arr[20]=180, а искомое число X=110.  
Очевидно, что `при более-менее равномерном распределении` позиция числа X ближе к arr[0], чем к arr[20], поэтому лучше диапазон делить не пополам, а в `отношении разницы искомого числа и величины числа на левой границе` к `разнице чисел между правой и левой границей`. То есть шаг от левой границы вправо (110-100)/(180-100) = 1/8 от диапазона индексов (0 - 20), то есть примерно 2.5 индекса, но, конечно, индексы следует окрулять до целого.  

## task 03  

- написать **функцию** `бинарного поиска` ПОЗИЦИИ заданного слова в списке слов русского языка  
- список слов загрузить из `words_utf.txt`  
- проверить работу своей функции на списке разыскиваемых слов из файла `wanted_words.txt`  
- ваша функция должна возвращать индекс позиции разыскиваемого слова в общем списке слов  
- доделать функцию чтобы она показывала сколько шагов поиска было сделано  

```txt
- в процессе испытаний Вы обнаружите, что не все слова  
  находятся в общем списке слов (хотя они там на самом деле есть)  
- требуется выяснить причины и исправить код  
```

Для чтения текстового файла можете использовать:  
`let txt = require('fs').readFileSync()`  

Для получения списка строк из `txt` можно разбить строку `txt` на массив строк так - `txt.split('\n')` или так `txt.split(/\r\n|\n/)` .  

Далее уже работаете с массивом строк (слов).  

---  

> ...  
